{"pageProps":{"frontMatter":{"title":"FileFerry","subtitle":"Building a Secure, Peer-to-Peer File Sharing App from Scratch","type":"personal","description":"FileFerry is a browser-based, peer-to-peer file sharing application that allows for secure, direct file transfers between any two browsers. Inspired by the command-line utility magic-wormhole, it uses WebRTC and the libp2p library. The project implement a custom protocol for reliable transfers over unstable connections, including checksum validation and an acknowledgement system, built with TypeScript and TailwindCSS.","keywords":"FileFerry, peer-to-peer file sharing, WebRTC, libp2p, js-libp2p, magic-wormhole, browser file transfer, secure file sharing, Golang, WASM, WebSockets, STUN, TURN, NAT hole punching, TypeScript, TailwindCSS, self-hosted file sharing","github":"https://github.com/smp46/fileferry","featured":true,"heroImage":"https://cdn.statically.io/gh/smp46/FileFerry/main/public/screenshot.png","date":"2025-06-23","created":"2025-06-23","updated":"2025-06-23","readingTime":"2 min read","wordCount":282,"minutes":2},"mdxSource":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    blockquote: \"blockquote\",\n    em: \"em\",\n    h1: \"h1\",\n    h2: \"h2\",\n    h3: \"h3\",\n    img: \"img\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://cdn.statically.io/gh/smp46/FileFerry/main/public/favicon/web-app-manifest-192x192.png\",\n        alt: \"Flow Chart\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      id: \"fileferry-building-a-secure-peer-to-peer-file-sharing-app-from-scratch\",\n      children: \"FileFerry: Building a Secure, Peer-to-Peer File Sharing App from Scratch\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"motivation\",\n      children: \"Motivation\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"I'm a big fan and user of the file-sharing utility\\n\", _jsx(_components.a, {\n        href: \"https://github.com/magic-wormhole/magic-wormhole\",\n        children: \"magic-wormhole\"\n      }), \". An\\neasy-to-use utility that allows you to transfer a folder or file between any two\\ndevices running a magic-wormhole client, using a phrase to connect. However, the\\nclient is, in my opinion, the limiting factor. It is usually a command-line\\nutility, requiring both a command line and a computer to run it on. Although it\\ncan be run through Termux on Android, that's not quite the user experience I'm\\nafter. So what if I could bring magic-wormhole to the browser?\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"initial-idea-literally-bring-magic-wormhole-to-the-browser\",\n      children: \"Initial Idea: Literally Bring Magic-Wormhole to the Browser\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Being the genius I am (\", _jsx(_components.em, {\n        children: \"sarcasm\"\n      }), \") I thought I could literally just bring the\\nwormhole-client to the browser. My preferred client is\\n\", _jsx(_components.a, {\n        href: \"https://github.com/psanford/wormhole-william\",\n        children: \"wormhole-william\"\n      }), \", an\\nimplementation of magic-wormhole written in Golang. A cool feature of Golang is\\nthat anything \", _jsx(_components.em, {\n        children: \"can\"\n      }), \" be compiled to WASM, WebAssembly. So I thought I could just\\nmake a web interface for wormhole-william, compile it to WASM and boom,\\nbrowser-based file sharing!\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"No, that's not how it works :(\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"peer-to-peer-in-the-browser-and-its-limitations\",\n      children: \"Peer-to-Peer in the Browser and its Limitations\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"While WASM is super cool tech, a browser is still a browser. And that means\\n\", _jsx(_components.a, {\n        href: \"https://thenewstack.io/webassembly/case-study-a-webassembly-failure-and-lessons-learned/\",\n        children: \"limitations\"\n      }), \".\\nFor today, the important limitation is \\\"You cannot access the network in an\\nunpermissioned way.\\\" This means the traditional and established method of TCP\\nhole-punching to establish direct network connections between two otherwise\\nunconnected peers doesn't work. I guess this is understandable, but it did throw\\na spanner in the works. Magic-wormhole works \", _jsx(_components.em, {\n        children: \"exclusively\"\n      }), \" via TCP\\nhole-punching, a fact I discovered only after building a basic prototype in the\\nbrowser.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So what can you do in the browser?\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.a, {\n        href: \"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API\",\n        children: \"WebSockets\"\n      }), \"\\nand \", _jsx(_components.a, {\n        href: \"https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API\",\n        children: \"WebRTC\"\n      }), \" are\\nwhat you can do in the browser. WebSockets are our equivalent of a basic TCP\\nstream in the browser. The WebSockets API \\\"makes it possible to open a two-way\\ninteractive communication session between the user's browser and a server.\\\"\\nWhich sounds pretty neat, I'm going to need to make some connections beyond HTTP\\nrequests. And WebRTC \\\"enables Web applications and sites to ... exchange\\narbitrary data between browsers without requiring an intermediary.\\\" Sounds like\\nexactly what I would need for a browser-based file sharing application, how\\neasy. With WebSockets for creating streams and WebRTC as our transfer protocol,\\nall it needs is some magic to get the direct connection.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"the-imperfect-magic-libp2p\",\n      children: \"The (Imperfect) Magic: libp2p\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"libp2p is an open source networking library used by the world's most important\\ndistributed systems such as Ethereum, IPFS, Filecoin, Optimism and countless\\nothers. There are native implementations in Go, Rust, \", _jsx(_components.strong, {\n          children: \"Javascript\"\n        }), \", C++,\\nNim, Java/Kotlin, Python, .Net, Swift and Zig. It is the simplest solution for\\nglobal scale peer-to-peer networking and includes support for pub-sub message\\npassing, distributed hash tables, \", _jsx(_components.strong, {\n          children: \"NAT hole punching and browser-to-browser\\ndirect communication.\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Libp2p is what I used to build FileFerry, and it is awesome. As a whole, libp2p\\nis a specification for bringing together a lot of cool networking technologies\\ninto a single framework. And look right there in the blurb it says it supports\\nJavascript, hole punching and direct browser-to-browser communication.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Okay, so the scope of the project has increased a little... but it seems I have\\nthe tools to make my browser-based alternative to magic-wormhole.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"building-fileferry-with-js-libp2p\",\n      children: \"Building FileFerry with js-libp2p\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This has been a long journey, and let's just say I'm glad Neovim doesn't keep\\ntrack of usage by number of hours.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"wrangling-js-libp2p\",\n      children: \"Wrangling js-libp2p\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"While js-libp2p does handle the magic, it isn't exactly simple nor\\nstraightforward. I started with this\\n\", _jsx(_components.a, {\n        href: \"https://github.com/libp2p/js-libp2p-example-webrtc-private-to-private/\",\n        children: \"webrtc browser-to-browser example\"\n      }), \"\\nand went from there. Unfortunately, while libp2p has some cool built-in\\nprotocols like gossip-sub for chat apps. It \", _jsx(_components.em, {\n        children: \"doesn't\"\n      }), \" offer a file transfer protocol, so that was my job to\\nimplement. But in theory if I can get a stream, I should be able to just push\\nsome data through it, save it on the other end and boom, file-sharing done.\\nWell, in a perfect world maybe, but I found WebSockets and WebRTC isn't exactly\\ntailored to shoving large amounts of data through a stream as fast as possible.\\nConnection stability was a gigantic headache, connections \", _jsx(_components.em, {\n        children: \"will\"\n      }), \" drop and\\nhandling that is a pain.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"complete-transfers-over-incomplete-connections\",\n      children: \"Complete Transfers over Incomplete Connections\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The general idea seemed easy, if I just track at an application level how far\\nthrough a file transfer the app is then if a connection drops, it can reconnect\\nand keep on going. And that's how I started. But there are issues:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"How do we know when to reconnect?\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"How do we know that the data arrived all in one piece?\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"What if the Sender gets ahead of the Receiver?\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To address the first issue, I implemented a Connection Management class that\\nkeeps track of, handles and directs connections. I also made it the Sender's job\\nto reconnect upon connection loss. It sounds simple now, but working out how the\\nspecific implementation required a lot of reading of the\\n\", _jsx(_components.a, {\n        href: \"https://github.com/libp2p/specs\",\n        children: \"libp2p spec\"\n      }), \", reading the\\n\", _jsx(_components.a, {\n        href: \"https://github.com/libp2p/js-libp2p\",\n        children: \"source code\"\n      }), \" and trial and error.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The second issue was much easier, and dare I say fun. Hashing to produce a\\nchecksum. Now most hashing I can think of works by taking a complete file and\\nprocessing it all at once. But only the Sender has a complete file, at least\\nuntil the transfer is done. Instead of having the Receiver process the whole\\nfile again and hash it after receiving, I decided I could do it during the\\ntransfer. I could do it during the transfer, this way it would be less of an\\nissue if the connection dropped as well. So I picked an algorithm I had actually\\nused in the Algorithms and Datastructures class I took at uni, FNV1a because it\\nis\\n\", _jsx(_components.a, {\n        href: \"https://softwareengineering.stackexchange.com/questions/49550/which-hashing-algorithm-is-best-for-uniqueness-and-speed/145633#145633\",\n        children: \"very fast and relatively secure\"\n      }), \".\\nOkay so now the Sender makes the initial checksum part of the file header and\\nthe Receiver can compare its final result against it. Another issue down.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The final issue, I also solved thanks to some networking basics I was taught at\\nuni. The stream behaves like a UDP connection, you can write and read data to it\\nbut who is to say whether that data did or didn't arrive. So I thought what if I\\ntook a page from TCP and implemented an \", _jsx(_components.em, {\n        children: \"ACK\"\n      }), \"nowledgement system. Basically,\\nevery 200 chunks the Sender will stop sending and wait for the Receiver to send\\nan acknowledgement that it has received the last batch. This helped especially\\nwhen connection drop-outs occurred, often the sender would reconnect and keep\\nblasting data while the receiver is still trying to catch up.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"a-poorly-made-overview\",\n      children: \"A (Poorly Made) Overview\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://cdn.statically.io/gh/smp46/smp46.me/nextjs/public/assets/fileferry/flowchart.webp\",\n        alt: \"Flow Chart\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"the-ui\",\n      children: \"The UI\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The nautical theme was picked mostly because I was looking for something\\ninteresting. As I'm not a UI designer, it felt easier to make something a little\\ndifferent. The site uses purely HTML/Typescript/TailwindCSS. And I'm not ashamed\\nto admit Claude Opus was definitely the lead CSS designer, I thought it was\\npretty incredible the stuff it can come up with purely in CSS. Zero pre-rendered\\nassets (images) are used, it's all CSS, SVGs and text.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"the-backend\",\n      children: \"The Backend\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To bring it all together, I self-host two of the three required back-end\\nservers:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"The Passphrase Server\"\n        }), \": A simple API that provides access to a database. A\\nsender can make a POST request with a key value pair of their passphrase (the\\nkey) and their public peer address (the value). A receiver, with a shared\\npassphrase, can then make a GET request (with the passphrase) and receive the\\nSender's peer address. The database entry is then immediately deleted.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"WebRTC Necessities\"\n        }), \": For a more detailed explanation of exactly how these\\ntwo servers come into play I suggest\\n\", _jsx(_components.a, {\n          href: \"https://www.cloudflare.com/learning/video/turn-server/\",\n          children: \"this article\"\n        }), \". But\\nsimply put:\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"The CoTURN Server\"\n            }), \": The fallback relay that is used if a direct\\nconnection can't be made between two clients.\\n\", _jsx(_components.a, {\n              href: \"https://github.com/coturn/coturn\",\n              children: \"Coturn\"\n            }), \" is just an open source\\nimplementation that I utilised for this project.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"The STUN Servers\"\n            }), \": These are public external services that help with\\nclient discoverability and establishing direct connections with WebRTC. As\\nthese use very little bandwith, there are many publicly available. I used\\n\", _jsx(_components.a, {\n              href: \"https://github.com/pradt2/always-online-stun\",\n              children: \"this list\"\n            }), \" and my own\\n\", _jsx(_components.a, {\n              href: \"https://github.com/smp46/geoip-api\",\n              children: \"fork of a GeoIP API\"\n            }), \" to retrieve the\\nthree geographically closest STUN servers to the client.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"the-result-a-demo\",\n      children: \"The Result: A Demo\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://cdn.statically.io/gh/smp46/smp46.me/nextjs/public/assets/fileferry/output.gif\",\n        alt: \"Demo\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Visit \", _jsx(_components.a, {\n        href: \"https://fileferry.xyz\",\n        children: \"fileferry.xyz\"\n      }), \" to try it yourself!\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"to-conclude\",\n      children: \"To Conclude\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This turned into a really fun and challenging project, and has definitely\\ninspired me to work further with the libp2p framework in the future. Due to the\\ncomplexity of the project I spent a long time getting into the weeds, reading\\nand trying to understand the source code of js-libp2p. I ran into many problems\\nthat neither Google nor ChatGPT could help me with, which made it a very\\nrewarding project to complete.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But for now, I am finished with FileFerry and will enjoy my new easy way to\\nshare files in the browser.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"FileFerry","subtitle":"Building a Secure, Peer-to-Peer File Sharing App from Scratch","type":"personal","description":"FileFerry is a browser-based, peer-to-peer file sharing application that allows for secure, direct file transfers between any two browsers. Inspired by the command-line utility magic-wormhole, it uses WebRTC and the libp2p library. The project implement a custom protocol for reliable transfers over unstable connections, including checksum validation and an acknowledgement system, built with TypeScript and TailwindCSS.","keywords":"FileFerry, peer-to-peer file sharing, WebRTC, libp2p, js-libp2p, magic-wormhole, browser file transfer, secure file sharing, Golang, WASM, WebSockets, STUN, TURN, NAT hole punching, TypeScript, TailwindCSS, self-hosted file sharing","github":"https://github.com/smp46/fileferry","featured":true,"heroImage":"https://cdn.statically.io/gh/smp46/FileFerry/main/public/screenshot.png","date":"2025-06-23","created":"2025-06-23","updated":"2025-06-23"}}},"__N_SSG":true}