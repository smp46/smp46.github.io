{"pageProps":{"frontMatter":{"title":"FileFerry","subtitle":"Building a Secure, Peer-to-Peer File Sharing App from Scratch","type":"personal","description":"FileFerry is a browser-based, peer-to-peer file sharing application that allows for secure, direct file transfers between any two browsers. Inspired by the command-line utility magic-wormhole, it uses WebRTC and the libp2p library. The project implement a custom protocol for reliable transfers over unstable connections, including checksum validation and an acknowledgement system, built with TypeScript and TailwindCSS.","keywords":"FileFerry, peer-to-peer file sharing, WebRTC, libp2p, js-libp2p, magic-wormhole, browser file transfer, secure file sharing, Golang, WASM, WebSockets, STUN, TURN, NAT hole punching, TypeScript, TailwindCSS, self-hosted file sharing","github":"https://github.com/smp46/fileferry","featured":true,"heroImage":"https://cdn.statically.io/gh/smp46/FileFerry/main/public/screenshot.png","date":"2025-06-23","readingTime":"2 min read","wordCount":282,"minutes":2},"mdxSource":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    blockquote: \"blockquote\",\n    em: \"em\",\n    h1: \"h1\",\n    h2: \"h2\",\n    h3: \"h3\",\n    img: \"img\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      id: \"fileferry-building-a-secure-peer-to-peer-file-sharing-app-from-scratch\",\n      children: \"FileFerry: Building a Secure, Peer-to-Peer File Sharing App from Scratch\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://cdn.statically.io/gh/smp46/FileFerry/main/public/favicon/web-app-manifest-192x192.png\",\n        alt: \"Flow Chart\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"motivation\",\n      children: \"Motivation\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"I'm a big fan and user of the file-sharing utility \", _jsx(_components.a, {\n        href: \"https://github.com/magic-wormhole/magic-wormhole\",\n        children: \"magic-wormhole\"\n      }), \". An easy to use utility that allows you to transfer a folder or file between any two devices running a magic-wormhole client, using a phrase to connect. However, the client is in my opinion the limiting factor, it is usually a command line utility, requiring both a command line and a computer to run it on. Although it can be run through Termux on Android, that's not quite the user experience I'm after. So what if I could bring magic-wormhole to the browser?\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"initial-idea-literally-bring-magic-wormhole-to-the-browser\",\n      children: \"Initial Idea: Literally Bring Magic-Wormhole to the Browser\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Being the genius I am (\", _jsx(_components.em, {\n        children: \"sarcasm\"\n      }), \") I thought I could literally just bring the wormhole-client to the browser. My preferred client is \", _jsx(_components.a, {\n        href: \"https://github.com/psanford/wormhole-william\",\n        children: \"wormhole-william\"\n      }), \", an implementation of magic-wormhole written in Golang. A cool feature of Golang is anything \", _jsx(_components.em, {\n        children: \"can\"\n      }), \" be compiled to WASM, Web Assembly. So I thought I could just make a web interface for wormhole-william, compile it in WASM and boom, browser-based file sharing!\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"No that's not how it works :(\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"peer-to-peer-in-the-browser-and-its-limitations\",\n      children: \"Peer-to-Peer in the Browser and its Limitations\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"While WASM is super cool tech, a browser is still a browser. And that means \", _jsx(_components.a, {\n        href: \"https://thenewstack.io/webassembly/case-study-a-webassembly-failure-and-lessons-learned/\",\n        children: \"limitations\"\n      }), \". For today, the important limitation is \\\"You cannot access the network in an unpermissioned way.\\\" This means the traditional and established method of TCP hole-punching to establish direct network connections between two otherwise unconnected peers, doesn't work. I guess this is understandable, but it did throw a spanner in the works. Magic-wormhole works \", _jsx(_components.em, {\n        children: \"exclusively\"\n      }), \" via TCP hole-punching, which took me building a basic prototype in the browser to work out.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So what can you do in the browser?\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.a, {\n        href: \"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API\",\n        children: \"WebSockets\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API\",\n        children: \"WebRTC\"\n      }), \" is what you can do in the browser. WebSockets are our equivalent of a basic TCP stream in the browser, the API \\\"makes it possible to open a two-way interactive communication session between the user's browser and a server.\\\" Which sounds pretty neat, I'm going to need to make some connections beyond HTTP requests. And WebRTC \\\"enables Web applications and sites to ... exchange arbitrary data between browsers without requiring an intermediary.\\\" Sounds like exactly what I would need for a browser-based file sharing application, how easy. With WebSockets for creating streams and WebRTC as our transfer protocol, all it needs is some magic to get the direct connection.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"the-imperfect-magic-libp2p\",\n      children: \"The (Imperfect) Magic: libp2p\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"libp2p is an open source networking library used by the world's most important distributed systems such as Ethereum, IPFS, Filecoin, Optimism and countless others. There are native implementations in Go, Rust, \", _jsx(_components.strong, {\n          children: \"Javascript\"\n        }), \", C++, Nim, Java/Kotlin, Python, .Net, Swift and Zig. It is the simplest solution for global scale peer-to-peer networking and includes support for pub-sub message passing, distributed hash tables, \", _jsx(_components.strong, {\n          children: \"NAT hole punching and browser-to-browser direct communication.\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Libp2p is what I used to build FileFerry, and it is awesome. As a whole, libp2p is a specification for bringing together a lot of cool networking technologies into a single framework. And look right there in the blurb it says it supports Javascript, hole punching and direct browser-to-browser communication.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Okay, so the scope of the project has increased a little... but it seems I have the tools to make my browser-based alternative to magic-wormhole.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"building-fileferry-with-js-libp2p\",\n      children: \"Building FileFerry with js-libp2p\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This has been a long journey, and lets just say I'm glad Neovim doesn't keep track of usage by number of hours.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"wrangling-js-libp2p\",\n      children: \"Wrangling js-libp2p\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"While js-libp2p does handle the magic, it isn't exactly simple nor straightforward. I started with this \", _jsx(_components.a, {\n        href: \"https://github.com/libp2p/js-libp2p-example-webrtc-private-to-private/\",\n        children: \"webrtc browser to browser example\"\n      }), \" and went from there. Unfortunately, while libp2p does have some cool built in protocols like gossip-sub for chat apps. It \", _jsx(_components.em, {\n        children: \"doesn't\"\n      }), \" offer a file transfer protocol, so that was my job to implement. But in theory if I can get a stream, I should be able to just push some data through it, save it on the other end and boom, file-sharing done. Well, it a perfect world maybe, but I found WebSockets and WebRTC aren't exactly tailored to shoving large amounts of data through a stream as fast as possible. Connection stability was a gigantic headache, connections \", _jsx(_components.em, {\n        children: \"will\"\n      }), \" drop and handling that is a pain.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"complete-transfers-over-incomplete-connections\",\n      children: \"Complete Transfers over Incomplete Connections\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The general idea seemed easy, if I just track at an application level how far through a file transfer the app is then if a connection drops, it can reconnect and keep on going. And that's how I started. But there are issues:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"How do we know when to reconnect?\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"How do we know that the data arrived all in one piece?\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"What if the Sender gets ahead of the Receiver?\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To address the first issue,  I implemented a Connection Management class that keeps track of, handles and directs connections. And made it the sender's job to reconnect upon connection loss. It sounds simple now, but working how the specific implementation required a lot of reading of the \", _jsx(_components.a, {\n        href: \"https://github.com/libp2p/specs\",\n        children: \"libp2p spec\"\n      }), \", reading the \", _jsx(_components.a, {\n        href: \"https://github.com/libp2p/js-libp2p\",\n        children: \"source code\"\n      }), \" and trial and error.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The second issue was much easier, and dare I say fun. Hashing to produce a checksum. Now most hashing I can think of works by taking a complete file and processing it all at once. But only the Sender has a complete file, at least until the transfer is done, so I decided instead of having the Receiver process the whole file again and hash it after receiving. I could do it during the transfer, this way it would be less of an issue if the connection dropped as well. So I picked an algorithm I had actually used in the Algorithms and Datastructures class I took at uni, FNV1a because it is \", _jsx(_components.a, {\n        href: \"https://softwareengineering.stackexchange.com/questions/49550/which-hashing-algorithm-is-best-for-uniqueness-and-speed/145633#145633\",\n        children: \"very fast and relatively secure\"\n      }), \". Okay so now the Sender makes the initial checksum part of the file header and the Receiver can compare it's final result against it. Another issue down.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The final issue, I also solved thanks to some networking basics I was taught at uni. The stream behaves like a UDP connection, you can write and read data to it but who is to say whether they data did or didn't arrive. So I thought what if I took a page from TCP and implemented an \", _jsx(_components.em, {\n        children: \"ACK\"\n      }), \"nowledgement system. Basically, every 200 chunks the Sender will stop sending and wait for the Receiver to send an acknowledgement that it has received the last batch. This helped especially when connection drop-outs occurred, often the sender would reconnect and keep blasting data while the receiver is still trying to catch up.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"a-poorly-made-overview\",\n      children: \"A (Poorly Made) Overview\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://cdn.statically.io/gh/smp46/smp46.me/nextjs/public/assets/fileferry/flowchart.webp\",\n        alt: \"Flow Chart\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"the-ui\",\n      children: \"The UI\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The nautical themed was picked mostly because I was looking for something interesting, I'm not an UI designer so it felt easier to make something \", _jsx(_components.em, {\n        children: \"a little different\"\n      }), \". It uses purely HTML/Typescript/TailwindCSS. And I'm not ashamed to admit Claude Opus was definitely the lead CSS designer, I thought it was pretty incredible the stuff it can come up with purely in CSS. Zero pre-rendered assets (images) are used, its all CSS, SVGs and text.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"the-backend\",\n      children: \"The Backend\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To bring it all together, I self-host two of the three required back-end servers:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"The Passphrase Server\"\n        }), \": A simple API that provides access to a database. A sender can make a POST request with a key value pair of their passphrase (the key) and the their public peer address (the value). A receiver, with a shared passphrase, can then make a GET request with and receive the Sender's peer address. The database entry it then immediately deleted.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"WebRTC Necessities\"\n        }), \": For a more detailed explanation of exactly how these two servers come into play I suggest \", _jsx(_components.a, {\n          href: \"https://www.cloudflare.com/learning/video/turn-server/\",\n          children: \"this article\"\n        }), \". But simply put:\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"The CoTURN Server\"\n            }), \":  The fallback relay that is used if a direct connection can't be made between two clients. \", _jsx(_components.a, {\n              href: \"https://github.com/coturn/coturn\",\n              children: \"Coturn\"\n            }), \" is just an open source implementation that I utilised for this project.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"The STUN Servers\"\n            }), \": These are public external services that help with client discoverability and establishing direct connections with WebRTC. As these use very little bandwith, there are many publicly available. I used \", _jsx(_components.a, {\n              href: \"https://github.com/pradt2/always-online-stun\",\n              children: \"this list\"\n            }), \" and my own \", _jsx(_components.a, {\n              href: \"https://github.com/smp46/geoip-api\",\n              children: \"fork of a GeoIP API\"\n            }), \"  to retrieve the three geographically closest STUN servers to the client.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"the-result-a-demo\",\n      children: \"The Result: A Demo\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://cdn.statically.io/gh/smp46/smp46.me/nextjs/public/assets/fileferry/output.gif\",\n        alt: \"Demo\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Visit \", _jsx(_components.a, {\n        href: \"https://fileferry.xyz\",\n        children: \"fileferry.xyz\"\n      }), \" to try it yourself!\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"to-conclude\",\n      children: \"To Conclude\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This turned into a really fun challenging project, and has definitely inspired me to work further with the libp2p framework in the future. Due to the complexity of the project I spent a long time getting into the weeds, reading and trying to understand the source code of js-libp2p. Running into many problems that neither Google nor ChatGPT could help me with.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But for now, I am finished with FileFerry and will enjoy my new easy way to share files in the browser.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"FileFerry","subtitle":"Building a Secure, Peer-to-Peer File Sharing App from Scratch","type":"personal","description":"FileFerry is a browser-based, peer-to-peer file sharing application that allows for secure, direct file transfers between any two browsers. Inspired by the command-line utility magic-wormhole, it uses WebRTC and the libp2p library. The project implement a custom protocol for reliable transfers over unstable connections, including checksum validation and an acknowledgement system, built with TypeScript and TailwindCSS.","keywords":"FileFerry, peer-to-peer file sharing, WebRTC, libp2p, js-libp2p, magic-wormhole, browser file transfer, secure file sharing, Golang, WASM, WebSockets, STUN, TURN, NAT hole punching, TypeScript, TailwindCSS, self-hosted file sharing","github":"https://github.com/smp46/fileferry","featured":true,"heroImage":"https://cdn.statically.io/gh/smp46/FileFerry/main/public/screenshot.png","date":"2025-06-23"}}},"__N_SSG":true}