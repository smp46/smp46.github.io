<!DOCTYPE html><html><head><meta charSet="utf-8" data-next-head=""/><meta http-equiv="content-language" content="en-us" data-next-head=""/><meta name="author" content="Samuel Paynter " data-next-head=""/><meta name="viewport" content="width=device-width, initial-scale=1" data-next-head=""/><link rel="alternate" type="application/rss+xml" title="smp46 RSS Feed" href="https://cdn.statically.io/gh/smp46/smp46.me/nextjs/public/feeds/feed.xml" data-next-head=""/><link rel="alternate" type="application/atom+xml" title="smp46 Atom Feed" href="https://cdn.statically.io/gh/smp46/smp46.me/nextjs/public/feeds/atom.xml" data-next-head=""/><link rel="alternate" type="application/feed+json" title="smp46 JSON Feed" href="https://cdn.statically.io/gh/smp46/smp46.me/nextjs/public/feeds/feed.json" data-next-head=""/><title data-next-head="">FileFerry | Building a Secure, Peer-to-Peer File Sharing App from Scratch</title><meta name="description" content="FileFerry is a browser-based, peer-to-peer file sharing application that allows for secure, direct file transfers between any two browsers. Inspired by the command-line utility magic-wormhole, it uses WebRTC and the libp2p library. The project implement a custom protocol for reliable transfers over unstable connections, including checksum validation and an acknowledgement system, built with TypeScript and TailwindCSS." data-next-head=""/><meta name="keywords" content="FileFerry, peer-to-peer file sharing, WebRTC, libp2p, js-libp2p, magic-wormhole, browser file transfer, secure file sharing, Golang, WASM, WebSockets, STUN, TURN, NAT hole punching, TypeScript, TailwindCSS, self-hosted file sharing" data-next-head=""/><link rel="preload" href="/_next/static/css/71181eb91c2a512a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/71181eb91c2a512a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-8cac0b4b405cede1.js" defer=""></script><script src="/_next/static/chunks/framework-ee17a4c43a44d3e2.js" defer=""></script><script src="/_next/static/chunks/main-1a14f97a66d86e3f.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8f6cf5a370fff60a.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-70f4f431c3407748.js" defer=""></script><script src="/_next/static/cY_XpkuDpHxqBKfT8_Hxa/_buildManifest.js" defer=""></script><script src="/_next/static/cY_XpkuDpHxqBKfT8_Hxa/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex h-screen"><div class="sm:hidden fixed top-0 left-0 w-full bg-black text-white flex items-center justify-between px-8 py-4 z-50"><button class="text-white text-5xl flex items-center justify-center" aria-label="Open menu"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button><a href="/"><h2 class="sm:text-3xl text-5xl font-bold leading-none -translate-y-2 sm:translate-y-0">smp46</h2></a></div><div class="fixed top-0 left-0 h-screen bg-black text-white flex flex-col px-4 py-8 z-40
          transform -translate-x-full
          transition-transform duration-300 sm:translate-x-0 sm:static mt-8 w-64
          sm:flex-shrink-0 sm:mt-0 overflow-y-auto"><a href="/"><h2 class="text-5xl font-bold hidden sm:block">smp46</h2></a><div class="mt-4 flex space-x-3 sm:space-x-4"><a href="https://discord.com/users/335649164769886208" target="_blank" rel="noopener noreferrer" class="text-white sm:text-2xl text-4xl transition-transform duration-300 hover:scale-110" aria-label="Discord" data-umami-event="Clicked Discord Link" data-link="external"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 640 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M524.531,69.836a1.5,1.5,0,0,0-.764-.7A485.065,485.065,0,0,0,404.081,32.03a1.816,1.816,0,0,0-1.923.91,337.461,337.461,0,0,0-14.9,30.6,447.848,447.848,0,0,0-134.426,0,309.541,309.541,0,0,0-15.135-30.6,1.89,1.89,0,0,0-1.924-.91A483.689,483.689,0,0,0,116.085,69.137a1.712,1.712,0,0,0-.788.676C39.068,183.651,18.186,294.69,28.43,404.354a2.016,2.016,0,0,0,.765,1.375A487.666,487.666,0,0,0,176.02,479.918a1.9,1.9,0,0,0,2.063-.676A348.2,348.2,0,0,0,208.12,430.4a1.86,1.86,0,0,0-1.019-2.588,321.173,321.173,0,0,1-45.868-21.853,1.885,1.885,0,0,1-.185-3.126c3.082-2.309,6.166-4.711,9.109-7.137a1.819,1.819,0,0,1,1.9-.256c96.229,43.917,200.41,43.917,295.5,0a1.812,1.812,0,0,1,1.924.233c2.944,2.426,6.027,4.851,9.132,7.16a1.884,1.884,0,0,1-.162,3.126,301.407,301.407,0,0,1-45.89,21.83,1.875,1.875,0,0,0-1,2.611,391.055,391.055,0,0,0,30.014,48.815,1.864,1.864,0,0,0,2.063.7A486.048,486.048,0,0,0,610.7,405.729a1.882,1.882,0,0,0,.765-1.352C623.729,277.594,590.933,167.465,524.531,69.836ZM222.491,337.58c-28.972,0-52.844-26.587-52.844-59.239S193.056,219.1,222.491,219.1c29.665,0,53.306,26.82,52.843,59.239C275.334,310.993,251.924,337.58,222.491,337.58Zm195.38,0c-28.971,0-52.843-26.587-52.843-59.239S388.437,219.1,417.871,219.1c29.667,0,53.307,26.82,52.844,59.239C470.715,310.993,447.538,337.58,417.871,337.58Z"></path></svg></a><a href="https://github.com/smp46" target="_blank" rel="noopener noreferrer" class="text-white sm:text-2xl text-4xl transition-transform duration-300 hover:scale-110" aria-label="GitHub" data-umami-event="Clicked Github Link" data-link="external"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 496 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a><a href="https://linkedin.com/in/smp46" target="_blank" rel="noopener noreferrer" class="text-white sm:text-2xl text-4xl transition-transform duration-300 hover:scale-110" aria-label="LinkedIn" data-umami-event="Clicked LinkedIn Link" data-link="external"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg></a><a href="mailto:me@smp46.me" class="text-white sm:text-2xl text-4xl transition-transform duration-300 hover:scale-110" target="_blank" rel="noopener noreferrer" data-umami-event="Clicked email Link" data-link="external"><svg stroke="currentColor" fill="currentColor" stroke-width="0" role="img" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M24 5.457v13.909c0 .904-.732 1.636-1.636 1.636h-3.819V11.73L12 16.64l-6.545-4.91v9.273H1.636A1.636 1.636 0 0 1 0 19.366V5.457c0-2.023 2.309-3.178 3.927-1.964L5.455 4.64 12 9.548l6.545-4.91 1.528-1.145C21.69 2.28 24 3.434 24 5.457z"></path></svg></a><a class="text-white sm:text-2xl text-4xl transition-transform duration-300 hover:scale-110" target="_blank" data-umami-event="Clicked rss Link" data-link="external" href="https://cdn.statically.io/gh/smp46/smp46.me/nextjs/public/feeds/feed.xml"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M400 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zM112 416c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm157.533 0h-34.335c-6.011 0-11.051-4.636-11.442-10.634-5.214-80.05-69.243-143.92-149.123-149.123-5.997-.39-10.633-5.431-10.633-11.441v-34.335c0-6.535 5.468-11.777 11.994-11.425 110.546 5.974 198.997 94.536 204.964 204.964.352 6.526-4.89 11.994-11.425 11.994zm103.027 0h-34.334c-6.161 0-11.175-4.882-11.427-11.038-5.598-136.535-115.204-246.161-251.76-251.76C68.882 152.949 64 147.935 64 141.774V107.44c0-6.454 5.338-11.664 11.787-11.432 167.83 6.025 302.21 141.191 308.205 308.205.232 6.449-4.978 11.787-11.432 11.787z"></path></svg></a></div><nav class="flex flex-col sm:space-y-2 space-y-4 mt-6"><a class="text-white transition-transform duration-300 hover:scale-110 origin-left
                cursor-pointer sm:text-xl text-2xl" href="/">Welcome</a><a class="text-white transition-transform duration-300 hover:scale-110 origin-left
                cursor-pointer font-semibold sm:text-2xl text-3xl" href="/blog/">Blog</a><a class="text-white transition-transform duration-300 hover:scale-110 origin-left
                cursor-pointer sm:text-xl text-2xl" href="/experience/">Experience</a><a class="text-white transition-transform duration-300 hover:scale-110 origin-left
                cursor-pointer sm:text-xl text-2xl" href="/whoami/">whoami</a></nav></div><main class="flex-1 sm:ml-auto mt-16 sm:mt-0 sm:overflow-y-auto px-8 w-screen"><div class="min-h-screen relative overflow-hidden"><div class=" fixed inset-0 bg-white flex items-center justify-center z-29 sm:ml-64
          transition-opacity duration-500
          opacity-100 pointer-events-auto "><div class="animate-spin rounded-full h-16 w-16 border-4 border-black border-t-transparent"></div></div><div class="fixed top-0 right-0 w-[80px] h-[80px] z-50 sm:block hidden"><a class="github-corner" href="https://github.com/smp46/fileferry" target="_blank" rel="noopener noreferrer" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></div><div class="flex items-center justify-center min-h-screen mb-5 overflow-hidden"><div class="prose prose-headings:break-words prose-headings:hyphens-auto prose-lg prose-img:mx-auto prose-headings:mt-8 prose-headings:font-semibold prose-headings:text-black prose-h1:text-3xl sm:prose-h1:text-5xl prose-h1:font-extrabold sm:prose-h1:font-bold prose-h2:text-3xl prose-h3:text-3xl prose-h4:text-2xl prose-h5:text-2xl prose-h6:text-xl dark:prose-headings:text-black text-black overflow-hidden max-w-[100ch]"><p><img src="https://cdn.statically.io/gh/smp46/FileFerry/main/public/favicon/web-app-manifest-192x192.png" alt="Flow Chart"/></p>
<h1 id="fileferry-building-a-secure-peer-to-peer-file-sharing-app-from-scratch">FileFerry: Building a Secure, Peer-to-Peer File Sharing App from Scratch</h1>
<h2 id="motivation">Motivation</h2>
<p>I&#x27;m a big fan and user of the file-sharing utility
<a href="https://github.com/magic-wormhole/magic-wormhole">magic-wormhole</a>. An
easy-to-use utility that allows you to transfer a folder or file between any two
devices running a magic-wormhole client, using a phrase to connect. However, the
client is, in my opinion, the limiting factor. It is usually a command-line
utility, requiring both a command line and a computer to run it on. Although it
can be run through Termux on Android, that&#x27;s not quite the user experience I&#x27;m
after. So what if I could bring magic-wormhole to the browser?</p>
<h2 id="initial-idea-literally-bring-magic-wormhole-to-the-browser">Initial Idea: Literally Bring Magic-Wormhole to the Browser</h2>
<p>Being the genius I am (<em>sarcasm</em>) I thought I could literally just bring the
wormhole-client to the browser. My preferred client is
<a href="https://github.com/psanford/wormhole-william">wormhole-william</a>, an
implementation of magic-wormhole written in Golang. A cool feature of Golang is
that anything <em>can</em> be compiled to WASM, WebAssembly. So I thought I could just
make a web interface for wormhole-william, compile it to WASM and boom,
browser-based file sharing!</p>
<p>No, that&#x27;s not how it works :(</p>
<h2 id="peer-to-peer-in-the-browser-and-its-limitations">Peer-to-Peer in the Browser and its Limitations</h2>
<p>While WASM is super cool tech, a browser is still a browser. And that means
<a href="https://thenewstack.io/webassembly/case-study-a-webassembly-failure-and-lessons-learned/">limitations</a>.
For today, the important limitation is &quot;You cannot access the network in an
unpermissioned way.&quot; This means the traditional and established method of TCP
hole-punching to establish direct network connections between two otherwise
unconnected peers doesn&#x27;t work. I guess this is understandable, but it did throw
a spanner in the works. Magic-wormhole works <em>exclusively</em> via TCP
hole-punching, a fact I discovered only after building a basic prototype in the
browser.</p>
<p>So what can you do in the browser?</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">WebSockets</a>
and <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API">WebRTC</a> are
what you can do in the browser. WebSockets are our equivalent of a basic TCP
stream in the browser. The WebSockets API &quot;makes it possible to open a two-way
interactive communication session between the user&#x27;s browser and a server.&quot;
Which sounds pretty neat, I&#x27;m going to need to make some connections beyond HTTP
requests. And WebRTC &quot;enables Web applications and sites to ... exchange
arbitrary data between browsers without requiring an intermediary.&quot; Sounds like
exactly what I would need for a browser-based file sharing application, how
easy. With WebSockets for creating streams and WebRTC as our transfer protocol,
all it needs is some magic to get the direct connection.</p>
<h2 id="the-imperfect-magic-libp2p">The (Imperfect) Magic: libp2p</h2>
<blockquote>
<p>libp2p is an open source networking library used by the world&#x27;s most important
distributed systems such as Ethereum, IPFS, Filecoin, Optimism and countless
others. There are native implementations in Go, Rust, <strong>Javascript</strong>, C++,
Nim, Java/Kotlin, Python, .Net, Swift and Zig. It is the simplest solution for
global scale peer-to-peer networking and includes support for pub-sub message
passing, distributed hash tables, <strong>NAT hole punching and browser-to-browser
direct communication.</strong></p>
</blockquote>
<p>Libp2p is what I used to build FileFerry, and it is awesome. As a whole, libp2p
is a specification for bringing together a lot of cool networking technologies
into a single framework. And look right there in the blurb it says it supports
Javascript, hole punching and direct browser-to-browser communication.</p>
<p>Okay, so the scope of the project has increased a little... but it seems I have
the tools to make my browser-based alternative to magic-wormhole.</p>
<h2 id="building-fileferry-with-js-libp2p">Building FileFerry with js-libp2p</h2>
<p>This has been a long journey, and let&#x27;s just say I&#x27;m glad Neovim doesn&#x27;t keep
track of usage by number of hours.</p>
<h3 id="wrangling-js-libp2p">Wrangling js-libp2p</h3>
<p>While js-libp2p does handle the magic, it isn&#x27;t exactly simple nor
straightforward. I started with this
<a href="https://github.com/libp2p/js-libp2p-example-webrtc-private-to-private/">webrtc browser-to-browser example</a>
and went from there. Unfortunately, while libp2p has some cool built-in
protocols like gossip-sub for chat apps. It <em>doesn&#x27;t</em> offer a file transfer protocol, so that was my job to
implement. But in theory if I can get a stream, I should be able to just push
some data through it, save it on the other end and boom, file-sharing done.
Well, in a perfect world maybe, but I found WebSockets and WebRTC isn&#x27;t exactly
tailored to shoving large amounts of data through a stream as fast as possible.
Connection stability was a gigantic headache, connections <em>will</em> drop and
handling that is a pain.</p>
<h3 id="complete-transfers-over-incomplete-connections">Complete Transfers over Incomplete Connections</h3>
<p>The general idea seemed easy, if I just track at an application level how far
through a file transfer the app is then if a connection drops, it can reconnect
and keep on going. And that&#x27;s how I started. But there are issues:</p>
<ul>
<li>How do we know when to reconnect?</li>
<li>How do we know that the data arrived all in one piece?</li>
<li>What if the Sender gets ahead of the Receiver?</li>
</ul>
<p>To address the first issue, I implemented a Connection Management class that
keeps track of, handles and directs connections. I also made it the Sender&#x27;s job
to reconnect upon connection loss. It sounds simple now, but working out how the
specific implementation required a lot of reading of the
<a href="https://github.com/libp2p/specs">libp2p spec</a>, reading the
<a href="https://github.com/libp2p/js-libp2p">source code</a> and trial and error.</p>
<p>The second issue was much easier, and dare I say fun. Hashing to produce a
checksum. Now most hashing I can think of works by taking a complete file and
processing it all at once. But only the Sender has a complete file, at least
until the transfer is done. Instead of having the Receiver process the whole
file again and hash it after receiving, I decided I could do it during the
transfer. I could do it during the transfer, this way it would be less of an
issue if the connection dropped as well. So I picked an algorithm I had actually
used in the Algorithms and Datastructures class I took at uni, FNV1a because it
is
<a href="https://softwareengineering.stackexchange.com/questions/49550/which-hashing-algorithm-is-best-for-uniqueness-and-speed/145633#145633">very fast and relatively secure</a>.
Okay so now the Sender makes the initial checksum part of the file header and
the Receiver can compare its final result against it. Another issue down.</p>
<p>The final issue, I also solved thanks to some networking basics I was taught at
uni. The stream behaves like a UDP connection, you can write and read data to it
but who is to say whether that data did or didn&#x27;t arrive. So I thought what if I
took a page from TCP and implemented an <em>ACK</em>nowledgement system. Basically,
every 200 chunks the Sender will stop sending and wait for the Receiver to send
an acknowledgement that it has received the last batch. This helped especially
when connection drop-outs occurred, often the sender would reconnect and keep
blasting data while the receiver is still trying to catch up.</p>
<h3 id="a-poorly-made-overview">A (Poorly Made) Overview</h3>
<p><img src="https://cdn.statically.io/gh/smp46/smp46.me/nextjs/public/assets/fileferry/flowchart.webp" alt="Flow Chart"/></p>
<h3 id="the-ui">The UI</h3>
<p>The nautical theme was picked mostly because I was looking for something
interesting. As I&#x27;m not a UI designer, it felt easier to make something a little
different. The site uses purely HTML/Typescript/TailwindCSS. And I&#x27;m not ashamed
to admit Claude Opus was definitely the lead CSS designer, I thought it was
pretty incredible the stuff it can come up with purely in CSS. Zero pre-rendered
assets (images) are used, it&#x27;s all CSS, SVGs and text.</p>
<h3 id="the-backend">The Backend</h3>
<p>To bring it all together, I self-host two of the three required back-end
servers:</p>
<ul>
<li><strong>The Passphrase Server</strong>: A simple API that provides access to a database. A
sender can make a POST request with a key value pair of their passphrase (the
key) and their public peer address (the value). A receiver, with a shared
passphrase, can then make a GET request (with the passphrase) and receive the
Sender&#x27;s peer address. The database entry is then immediately deleted.</li>
<li><strong>WebRTC Necessities</strong>: For a more detailed explanation of exactly how these
two servers come into play I suggest
<a href="https://www.cloudflare.com/learning/video/turn-server/">this article</a>. But
simply put:<!-- -->
<ul>
<li><strong>The CoTURN Server</strong>: The fallback relay that is used if a direct
connection can&#x27;t be made between two clients.
<a href="https://github.com/coturn/coturn">Coturn</a> is just an open source
implementation that I utilised for this project.</li>
<li><strong>The STUN Servers</strong>: These are public external services that help with
client discoverability and establishing direct connections with WebRTC. As
these use very little bandwith, there are many publicly available. I used
<a href="https://github.com/pradt2/always-online-stun">this list</a> and my own
<a href="https://github.com/smp46/geoip-api">fork of a GeoIP API</a> to retrieve the
three geographically closest STUN servers to the client.</li>
</ul>
</li>
</ul>
<h2 id="the-result-a-demo">The Result: A Demo</h2>
<p><img src="https://cdn.statically.io/gh/smp46/smp46.me/nextjs/public/assets/fileferry/output.gif" alt="Demo"/></p>
<p>Visit <a href="https://fileferry.xyz">fileferry.xyz</a> to try it yourself!</p>
<h2 id="to-conclude">To Conclude</h2>
<p>This turned into a really fun and challenging project, and has definitely
inspired me to work further with the libp2p framework in the future. Due to the
complexity of the project I spent a long time getting into the weeds, reading
and trying to understand the source code of js-libp2p. I ran into many problems
that neither Google nor ChatGPT could help me with, which made it a very
rewarding project to complete.</p>
<p>But for now, I am finished with FileFerry and will enjoy my new easy way to
share files in the browser.</p></div><a href="https://github.com/smp46/fileferry" target="_blank" rel="noopener noreferrer" aria-label="View source on GitHub" class="fixed bottom-4 bg-white rounded-full right-4 z-28 text-black hover:scale-110 transition-transform duration-200 sm:hidden block"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 496 512" class="text-3xl" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontMatter":{"title":"FileFerry","subtitle":"Building a Secure, Peer-to-Peer File Sharing App from Scratch","type":"personal","description":"FileFerry is a browser-based, peer-to-peer file sharing application that allows for secure, direct file transfers between any two browsers. Inspired by the command-line utility magic-wormhole, it uses WebRTC and the libp2p library. The project implement a custom protocol for reliable transfers over unstable connections, including checksum validation and an acknowledgement system, built with TypeScript and TailwindCSS.","keywords":"FileFerry, peer-to-peer file sharing, WebRTC, libp2p, js-libp2p, magic-wormhole, browser file transfer, secure file sharing, Golang, WASM, WebSockets, STUN, TURN, NAT hole punching, TypeScript, TailwindCSS, self-hosted file sharing","github":"https://github.com/smp46/fileferry","featured":true,"heroImage":"https://cdn.statically.io/gh/smp46/FileFerry/main/public/screenshot.png","date":"2025-06-23","created":"2025-06-23","updated":"2025-06-23","readingTime":"2 min read","wordCount":282,"minutes":2},"mdxSource":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    blockquote: \"blockquote\",\n    em: \"em\",\n    h1: \"h1\",\n    h2: \"h2\",\n    h3: \"h3\",\n    img: \"img\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://cdn.statically.io/gh/smp46/FileFerry/main/public/favicon/web-app-manifest-192x192.png\",\n        alt: \"Flow Chart\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      id: \"fileferry-building-a-secure-peer-to-peer-file-sharing-app-from-scratch\",\n      children: \"FileFerry: Building a Secure, Peer-to-Peer File Sharing App from Scratch\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"motivation\",\n      children: \"Motivation\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"I'm a big fan and user of the file-sharing utility\\n\", _jsx(_components.a, {\n        href: \"https://github.com/magic-wormhole/magic-wormhole\",\n        children: \"magic-wormhole\"\n      }), \". An\\neasy-to-use utility that allows you to transfer a folder or file between any two\\ndevices running a magic-wormhole client, using a phrase to connect. However, the\\nclient is, in my opinion, the limiting factor. It is usually a command-line\\nutility, requiring both a command line and a computer to run it on. Although it\\ncan be run through Termux on Android, that's not quite the user experience I'm\\nafter. So what if I could bring magic-wormhole to the browser?\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"initial-idea-literally-bring-magic-wormhole-to-the-browser\",\n      children: \"Initial Idea: Literally Bring Magic-Wormhole to the Browser\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Being the genius I am (\", _jsx(_components.em, {\n        children: \"sarcasm\"\n      }), \") I thought I could literally just bring the\\nwormhole-client to the browser. My preferred client is\\n\", _jsx(_components.a, {\n        href: \"https://github.com/psanford/wormhole-william\",\n        children: \"wormhole-william\"\n      }), \", an\\nimplementation of magic-wormhole written in Golang. A cool feature of Golang is\\nthat anything \", _jsx(_components.em, {\n        children: \"can\"\n      }), \" be compiled to WASM, WebAssembly. So I thought I could just\\nmake a web interface for wormhole-william, compile it to WASM and boom,\\nbrowser-based file sharing!\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"No, that's not how it works :(\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"peer-to-peer-in-the-browser-and-its-limitations\",\n      children: \"Peer-to-Peer in the Browser and its Limitations\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"While WASM is super cool tech, a browser is still a browser. And that means\\n\", _jsx(_components.a, {\n        href: \"https://thenewstack.io/webassembly/case-study-a-webassembly-failure-and-lessons-learned/\",\n        children: \"limitations\"\n      }), \".\\nFor today, the important limitation is \\\"You cannot access the network in an\\nunpermissioned way.\\\" This means the traditional and established method of TCP\\nhole-punching to establish direct network connections between two otherwise\\nunconnected peers doesn't work. I guess this is understandable, but it did throw\\na spanner in the works. Magic-wormhole works \", _jsx(_components.em, {\n        children: \"exclusively\"\n      }), \" via TCP\\nhole-punching, a fact I discovered only after building a basic prototype in the\\nbrowser.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So what can you do in the browser?\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.a, {\n        href: \"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API\",\n        children: \"WebSockets\"\n      }), \"\\nand \", _jsx(_components.a, {\n        href: \"https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API\",\n        children: \"WebRTC\"\n      }), \" are\\nwhat you can do in the browser. WebSockets are our equivalent of a basic TCP\\nstream in the browser. The WebSockets API \\\"makes it possible to open a two-way\\ninteractive communication session between the user's browser and a server.\\\"\\nWhich sounds pretty neat, I'm going to need to make some connections beyond HTTP\\nrequests. And WebRTC \\\"enables Web applications and sites to ... exchange\\narbitrary data between browsers without requiring an intermediary.\\\" Sounds like\\nexactly what I would need for a browser-based file sharing application, how\\neasy. With WebSockets for creating streams and WebRTC as our transfer protocol,\\nall it needs is some magic to get the direct connection.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"the-imperfect-magic-libp2p\",\n      children: \"The (Imperfect) Magic: libp2p\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"libp2p is an open source networking library used by the world's most important\\ndistributed systems such as Ethereum, IPFS, Filecoin, Optimism and countless\\nothers. There are native implementations in Go, Rust, \", _jsx(_components.strong, {\n          children: \"Javascript\"\n        }), \", C++,\\nNim, Java/Kotlin, Python, .Net, Swift and Zig. It is the simplest solution for\\nglobal scale peer-to-peer networking and includes support for pub-sub message\\npassing, distributed hash tables, \", _jsx(_components.strong, {\n          children: \"NAT hole punching and browser-to-browser\\ndirect communication.\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Libp2p is what I used to build FileFerry, and it is awesome. As a whole, libp2p\\nis a specification for bringing together a lot of cool networking technologies\\ninto a single framework. And look right there in the blurb it says it supports\\nJavascript, hole punching and direct browser-to-browser communication.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Okay, so the scope of the project has increased a little... but it seems I have\\nthe tools to make my browser-based alternative to magic-wormhole.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"building-fileferry-with-js-libp2p\",\n      children: \"Building FileFerry with js-libp2p\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This has been a long journey, and let's just say I'm glad Neovim doesn't keep\\ntrack of usage by number of hours.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"wrangling-js-libp2p\",\n      children: \"Wrangling js-libp2p\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"While js-libp2p does handle the magic, it isn't exactly simple nor\\nstraightforward. I started with this\\n\", _jsx(_components.a, {\n        href: \"https://github.com/libp2p/js-libp2p-example-webrtc-private-to-private/\",\n        children: \"webrtc browser-to-browser example\"\n      }), \"\\nand went from there. Unfortunately, while libp2p has some cool built-in\\nprotocols like gossip-sub for chat apps. It \", _jsx(_components.em, {\n        children: \"doesn't\"\n      }), \" offer a file transfer protocol, so that was my job to\\nimplement. But in theory if I can get a stream, I should be able to just push\\nsome data through it, save it on the other end and boom, file-sharing done.\\nWell, in a perfect world maybe, but I found WebSockets and WebRTC isn't exactly\\ntailored to shoving large amounts of data through a stream as fast as possible.\\nConnection stability was a gigantic headache, connections \", _jsx(_components.em, {\n        children: \"will\"\n      }), \" drop and\\nhandling that is a pain.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"complete-transfers-over-incomplete-connections\",\n      children: \"Complete Transfers over Incomplete Connections\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The general idea seemed easy, if I just track at an application level how far\\nthrough a file transfer the app is then if a connection drops, it can reconnect\\nand keep on going. And that's how I started. But there are issues:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"How do we know when to reconnect?\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"How do we know that the data arrived all in one piece?\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"What if the Sender gets ahead of the Receiver?\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To address the first issue, I implemented a Connection Management class that\\nkeeps track of, handles and directs connections. I also made it the Sender's job\\nto reconnect upon connection loss. It sounds simple now, but working out how the\\nspecific implementation required a lot of reading of the\\n\", _jsx(_components.a, {\n        href: \"https://github.com/libp2p/specs\",\n        children: \"libp2p spec\"\n      }), \", reading the\\n\", _jsx(_components.a, {\n        href: \"https://github.com/libp2p/js-libp2p\",\n        children: \"source code\"\n      }), \" and trial and error.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The second issue was much easier, and dare I say fun. Hashing to produce a\\nchecksum. Now most hashing I can think of works by taking a complete file and\\nprocessing it all at once. But only the Sender has a complete file, at least\\nuntil the transfer is done. Instead of having the Receiver process the whole\\nfile again and hash it after receiving, I decided I could do it during the\\ntransfer. I could do it during the transfer, this way it would be less of an\\nissue if the connection dropped as well. So I picked an algorithm I had actually\\nused in the Algorithms and Datastructures class I took at uni, FNV1a because it\\nis\\n\", _jsx(_components.a, {\n        href: \"https://softwareengineering.stackexchange.com/questions/49550/which-hashing-algorithm-is-best-for-uniqueness-and-speed/145633#145633\",\n        children: \"very fast and relatively secure\"\n      }), \".\\nOkay so now the Sender makes the initial checksum part of the file header and\\nthe Receiver can compare its final result against it. Another issue down.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The final issue, I also solved thanks to some networking basics I was taught at\\nuni. The stream behaves like a UDP connection, you can write and read data to it\\nbut who is to say whether that data did or didn't arrive. So I thought what if I\\ntook a page from TCP and implemented an \", _jsx(_components.em, {\n        children: \"ACK\"\n      }), \"nowledgement system. Basically,\\nevery 200 chunks the Sender will stop sending and wait for the Receiver to send\\nan acknowledgement that it has received the last batch. This helped especially\\nwhen connection drop-outs occurred, often the sender would reconnect and keep\\nblasting data while the receiver is still trying to catch up.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"a-poorly-made-overview\",\n      children: \"A (Poorly Made) Overview\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://cdn.statically.io/gh/smp46/smp46.me/nextjs/public/assets/fileferry/flowchart.webp\",\n        alt: \"Flow Chart\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"the-ui\",\n      children: \"The UI\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The nautical theme was picked mostly because I was looking for something\\ninteresting. As I'm not a UI designer, it felt easier to make something a little\\ndifferent. The site uses purely HTML/Typescript/TailwindCSS. And I'm not ashamed\\nto admit Claude Opus was definitely the lead CSS designer, I thought it was\\npretty incredible the stuff it can come up with purely in CSS. Zero pre-rendered\\nassets (images) are used, it's all CSS, SVGs and text.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"the-backend\",\n      children: \"The Backend\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To bring it all together, I self-host two of the three required back-end\\nservers:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"The Passphrase Server\"\n        }), \": A simple API that provides access to a database. A\\nsender can make a POST request with a key value pair of their passphrase (the\\nkey) and their public peer address (the value). A receiver, with a shared\\npassphrase, can then make a GET request (with the passphrase) and receive the\\nSender's peer address. The database entry is then immediately deleted.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"WebRTC Necessities\"\n        }), \": For a more detailed explanation of exactly how these\\ntwo servers come into play I suggest\\n\", _jsx(_components.a, {\n          href: \"https://www.cloudflare.com/learning/video/turn-server/\",\n          children: \"this article\"\n        }), \". But\\nsimply put:\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"The CoTURN Server\"\n            }), \": The fallback relay that is used if a direct\\nconnection can't be made between two clients.\\n\", _jsx(_components.a, {\n              href: \"https://github.com/coturn/coturn\",\n              children: \"Coturn\"\n            }), \" is just an open source\\nimplementation that I utilised for this project.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"The STUN Servers\"\n            }), \": These are public external services that help with\\nclient discoverability and establishing direct connections with WebRTC. As\\nthese use very little bandwith, there are many publicly available. I used\\n\", _jsx(_components.a, {\n              href: \"https://github.com/pradt2/always-online-stun\",\n              children: \"this list\"\n            }), \" and my own\\n\", _jsx(_components.a, {\n              href: \"https://github.com/smp46/geoip-api\",\n              children: \"fork of a GeoIP API\"\n            }), \" to retrieve the\\nthree geographically closest STUN servers to the client.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"the-result-a-demo\",\n      children: \"The Result: A Demo\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://cdn.statically.io/gh/smp46/smp46.me/nextjs/public/assets/fileferry/output.gif\",\n        alt: \"Demo\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Visit \", _jsx(_components.a, {\n        href: \"https://fileferry.xyz\",\n        children: \"fileferry.xyz\"\n      }), \" to try it yourself!\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"to-conclude\",\n      children: \"To Conclude\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This turned into a really fun and challenging project, and has definitely\\ninspired me to work further with the libp2p framework in the future. Due to the\\ncomplexity of the project I spent a long time getting into the weeds, reading\\nand trying to understand the source code of js-libp2p. I ran into many problems\\nthat neither Google nor ChatGPT could help me with, which made it a very\\nrewarding project to complete.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But for now, I am finished with FileFerry and will enjoy my new easy way to\\nshare files in the browser.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"FileFerry","subtitle":"Building a Secure, Peer-to-Peer File Sharing App from Scratch","type":"personal","description":"FileFerry is a browser-based, peer-to-peer file sharing application that allows for secure, direct file transfers between any two browsers. Inspired by the command-line utility magic-wormhole, it uses WebRTC and the libp2p library. The project implement a custom protocol for reliable transfers over unstable connections, including checksum validation and an acknowledgement system, built with TypeScript and TailwindCSS.","keywords":"FileFerry, peer-to-peer file sharing, WebRTC, libp2p, js-libp2p, magic-wormhole, browser file transfer, secure file sharing, Golang, WASM, WebSockets, STUN, TURN, NAT hole punching, TypeScript, TailwindCSS, self-hosted file sharing","github":"https://github.com/smp46/fileferry","featured":true,"heroImage":"https://cdn.statically.io/gh/smp46/FileFerry/main/public/screenshot.png","date":"2025-06-23","created":"2025-06-23","updated":"2025-06-23"}}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"FileFerry"},"buildId":"cY_XpkuDpHxqBKfT8_Hxa","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>