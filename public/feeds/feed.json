{
    "version": "https://jsonfeed.org/version/1",
    "title": "smp46",
    "home_page_url": "https://smp46.me",
    "feed_url": "https://smp46.me/feeds/feed.json",
    "description": "Projects, attempts and other things",
    "author": {},
    "items": [
        {
            "id": "https://smp46.me/projects/SmartGarage",
            "content_html": "\n# SmartGarage: A DIY Wireless Garage Door Control System with a Side of Machine Learning\n\n## Introduction\n\nOne day my friend Howie was over and he saw me open my garage door. Naturally he\ngot out the Flipper Zero he always carries in his bag and asks I use my garage\ndoor fob again, he captures and resends it easily. I thought that was odd,\nshouldn't there be, I don't know, maybe at least rolling codes on any modern\ngarage door opener. But I was inspired and thought if it's that easy surely I\ncould automate that with some lower cost hardware.\n\nSo I get thinking and I come up with the project you're reading right now. To\ncreate a system to remotely open and close my garage door without physically\nmodifying the opener itself (I live in a rental so unfortunately this was a\nrequirement). But hey that doesn't sound very ambitious and the year is 2024, so\nI have to to add aRtIFicIAlL inTELiGeNce in here somewhere. In all seriousness,\noften I leave the house and five minutes later start wondering if I did close my\ngarage door. So what if instead of wondering I could just check my\n[homepage](https://gethomepage.dev/) dashboard, or even get an email\nnotification if the garage door has been open too long. And how can I check if\nthe door is open or not without wiring anything in, easy, I'll just train an\nimage recognition model that can tell me just that.\n\nThis project ended up combining hardware hacking, machine learning, and a web\ninterface to create a practical solution using nothing but off the shelf (or the\ninternet) parts and a bit of coding elbow grease.\n\n![Final Result](https://cdn.statically.io/gh/smp46/smp46.github.io/nextjs/assets/smartgarage/1.jpg?q=85&f=webp)\n\nIt's hard to show a teaser of the final result because it has so many parts, but\nhere is what was the hardest part of the solution (I swear it's not a bomb).\n\n## Initial Attempts and Challenges\n\nI started with the hard part, how do I clone the garage door fob signal and\nresend it on command. The fob uses the 433MHz band for transmission. I happened\nto have a Raspberry Pi Zero W sitting in my drawer, so I go online and find the\nTexas Instruments CC1101 Sub-GHz transceiver (the same chip that is used by the\nFlipper Zero). This should let me capture the signal and sent it right on back.\nMore searching and I see there's plenty of drivers and other projects for this\ntransceiver so it can't be that hard to use right. I order one, a breadboard and\na wiring kit to put it together.\n\nAs soon as I got it, I started trying to cobble something together, I try a\n[CC1101 driver library](https://github.com/SpaceTeddy/CC1101), I find\n[a python interface for it even](https://github.com/fphammerle/python-cc1101).\nBut I don't have much luck.\n\nI get to the stage where I can receive some kind of signal, however to be honest\nI know nothing about radio and I'm only a CompSci student not an electrical\nengineer. Even though it is the same chip used by the Flipper Zero, there seems\nto be fair bit of special sauce that goes into being able to pull a signal out\nof the air cleanly, then resend it. Documentation for the drivers didn't make\nmuch sense to me, if there was any at all. So after weeks of trying I decide to\npivot to another approach (definitely not a skill issue... okay maybe a little).\n\nSo I have a crack at the other side of the project, training an image\nrecognition model to tell me if the door is open or not. I start with getting\nthe cheapest wireless security camera I can find off of chinese marketplace\nnumber 508 ([banggood.com](banggood.com)), configuring my firewall to never let\nit phone home (block all its internet access) and begin collecting data.\n\nTo do this I write a\n[Bash script for fetching security camera snapshots](https://gist.github.com/smp46/638484a6b0d3d1695666b6c678657ab9),\nand make it into a systemd service on my Debian home server. A few weeks later\nand I have hundreds of thousands of photos that can be categorised as open or\nclosed.\n\nI spent a while then doing some research on how exactly this whole machine\nlearning stuff works. I decided on making something with PyTorch. A little later\nand some long discussions with Professor GPT I have\n[two python scripts](https://github.com/smp46/SmartGarage/tree/ac813584dbb65167c8f29fbdaa52849de34d0e04).\nThe first lets me add my own training data onto the MobileNetV2 model (a\nlightweight neural network designed for mobile devices) and configure it to\nprovide a binary output, the second loads my custom model, takes the input of a\npicture and outputs: \"Opened or Closed\". Neat! However, knowing my garage door\nwas actually left open doesn't really help me if I can't remotely close it.\n\nA little over a year goes by, life goes on, and my garage remains dumb :(\n\nHowever, recently while procrastinating some other programming assignments I\nremembered this project. And I thought, if a fob can open and close the door,\nmaybe I can just automate pressing the button on the fob. Sometimes the simplest\nsolutions are the ones staring you right in the face all along...\n\n## The Hardware Hack\n\nSo I ordered a couple of generic garage door fobs off eBay that were compatible\nwith my opener. After adding them to the garage door (following the actual\nprocess in the manual), I started thinking about how I could simulate a button\npress with my Raspberry Pi Zero W.\n\nNow, I'm not an electrical engineer by any stretch, but I figured how\ncomplicated could a fob be. I carefully cracked open one of the generic fobs and\nexamined the PCB. After some poking around with a multimeter, I discovered\n the button on the fob just bridges two contacts on\nthe PCB. If I could find a way to bridge those contacts on command from the Pi,\nI'd be cooking.\n\n![fob_contacts](https://cdn.statically.io/gh/smp46/smp46.github.io/nextjs/assets/smartgarage/3.jpg?q=85&f=webp)\n\nHere is the naked fob and the contacts I needed to bridge.\n\nAfter some research, I figured out I needed:\n\n- [**Arduino Compatible 5V Relay**](https://www.jaycar.com.au/arduino-compatible-5v-relay/p/XC4419)\n  - This allows me to use the GPIO on the Pi to send a high signal, which can\n    then bridge the circuit. As the Pi can't \"bridge\" but it can send high low\n    signals.\n- [**220 Ohm 0.5 Watt Resistor**](https://www.jaycar.com.au/220-ohm-0-5-watt-metal-film-resistors-pack-of-8/p/RR0556)\n  - This prevents the unlikely chance of the Relay drawing too much current and\n    cooking my Pi (in the bad way).\n- Some wires to connect everything together (I used the ones that came with my\n  breadboard kit)\n- A bit of soldering skill (which I do not have)\n\nHere's the circuit I ended up with:\n![circuit_diagram](https://cdn.statically.io/gh/smp46/smp46.github.io/nextjs/assets/smartgarage/circuit.png?q=85&f=webp)\n\nI soldered two thin wires to the contact points either side of the fob's button,\nran them to the relay, and connected everything according to the diagram above.\nThe idea is simple: when GPIO pin 17 goes high, it activates the relay, which\nbridges the contacts on the fob, which sends the signal to open/close the garage\ndoor.\n\nTo test, I put together\n[a basic python script](https://gist.github.com/smp46/d68ac357b1ac97062de757412eb9bc09)\nthat makes GPIO17 high for half a second. And shockingly, the door opens.\nYippee!\n\nYou might be wondering what sleek professional way I put this all together:\n![final_circuit](https://cdn.statically.io/gh/smp46/smp46.github.io/nextjs/assets/smartgarage/4.jpg?q=85&f=webp)\nI'm honestly not sure what the correct way to package something like this is, am\ndefinitely open to feedback if anyone has any better ideas.\n\n## Teaching My Computer to See\n\nAfter getting the hardware working, I needed to tackle the \"smart\" part of my\nSmartGarage: teaching a computer to recognize whether my garage door was open or\nclosed from camera images. This meant dabbling in machine learning—specifically,\ncomputer vision.\n\n#### Data Collection: The Boring Bit\n\nHonestly, this was the hardest and most tedious part of making the image\nrecognition model. In order to train an accurate model, I needed a lot of data\nand I needed it categorised.\n\nSo I used that\n[bash script](https://gist.github.com/smp46/638484a6b0d3d1695666b6c678657ab9)\nthat saves a picture every minute, or every second during \"peak times\" i.e.\ntimes when the door is mostly likely to be open, to collect a lot of data.\n\nThe result:\n\n```bash\n$ ls ~/garage/training_imgs | wc -l\n158332\n```\n\nNow that might look nice - more data is more better right? Not quite. When\ntraining a model I discovered a _good dataset_ is a _balanced dataset_. And\nbalance is difficult when most of the time the garage door is not open. To\nremedy this I made that bash script collect more often when the door might be\nopen and used a\n[python script](https://gist.github.com/smp46/b92a8b312fcd92632b4b6de99c9d8af7)\nthat creates a lot of permutations of the same pictures.\n\nBut how do you categorise all those pictures? Slowly and manually...\n\nThe specific software I use is [XnView MP](https://www.xnview.com/en/xnviewmp/)\nwhich is just a more effecient image library manager with support for batch\nrenaming. That and moving the data set to a RAMdisk while I'm working with it\nhelped speed things up. As turns out handling over 150 thouseand ~20Kb files\nisn't super easy. Here's a snapshot of the exciting action:\n\n![sorting_gif](https://cdn.statically.io/gh/smp46/smp46.github.io/nextjs/assets/smartgarage/sorting.gif)\n\n#### The Training Process\n\nDuring my first attempt at this project, I put together\n[a set of Python scripts](https://github.com/smp46/SmartGarage/tree/ac813584dbb65167c8f29fbdaa52849de34d0e04)\nusing the MobileNetV2 model with PyTorch. For this revival, I upgraded to\nMobileNetV3, which is meant to be better overall without needing additional\ncompute, and made some adjustments to optimize the images for training.\n\n###### Why the MobileNet Model?\n\nI picked MobileNet predominantly because it's designed for mobile\ndevices—meaning it's not very computationally expensive. This is important as\nthe model needs to run against an image every 10 seconds, 24/7.\n\nAlso, I only have access to my Radeon 6950XT for training, which is a nice\ngaming GPU but in the world of AI, it's not particularly powerful. I tried\ntraining with the ConvNeXtV2 model (a much newer and heavier model), and the\ntraining was estimated to take 125 hours to complete. MobileNetV3, by\ncomparison, takes less than 45 minutes even with ~140,000 images in the dataset.\n\n###### How do Those Scripts Work?\n\nClick the Githhub icon on this page to view the project itself and all the code.\n\nBut the workflow looks a little like this, I clone the repo, mount it alongside\nthe training images in the\n[PyTorch docker container](https://rocm.docs.amd.com/projects/install-on-linux/en/develop/install/3rd-party/pytorch-install.html)\nand do something like this:\n\n```bash\nroot@docker:/train# python3 binaryTrainer.py train\nEnter the path to the training images: /train/training_imgs_sorted/\nWhat is the object you are trying to classify? Garage Door\nEnter the classification names separated by a comma: open,closed\nEnter the model name to save as: may10_bigdata_10_epochs\nEnter the number of epochs: 10\n```\n\nThe output of that model will be a file called `may10_bigdata_10_epochs.pth` and\na `config.ini`, this contains the additional training data needed for\npredictions and the configuration for the other script `justPredict.py`. That\nsecond script allows me to just pass it a file:\n\n```bash\nroot@docker:/train# python3 justPredict.py testing_imgs/garage5.jpg\nopen\n```\n\n###### Can I Give it a Go?\n\nPlease! I tried making the script fairly user-friendly, mostly so I don't have\nto remember the intricacies when I want to update / train a new model.\nCurrently, it is limited to a binary output i.e. a True or False classification.\nBut it does have some nice features like a progress bar and stopping training\nwhen it detects accuracy loss.\n\nWas all this ML stuff necessary? Probably not. Was there a simpler way to\nachieve this? Absolutely. But where's the fun in that? Plus, I learned a fair\nbit about machine learning in the process, which was kind of the point.\n\n## Putting It All Together\n\nWith the hardware and machine learning components working, I needed a way to tie\neverything together into a cohesive system. Let me illustrate the architecture\nand then I can explain why this is a perfectly sane project (and not at all an\novercomplicated solution to a problem that probably has a $20 commercial\nalternative):\n\n###### Architecture\n\nThe system follows a microservices approach, with each component handling a\nspecific responsibility and communicating via HTTP APIs. The Rust HTTP server\nruns on the Pi Zero W, the rest is running on my homeserver both in and out of\nDocker containers.\n\n![software_architecture](https://cdn.statically.io/gh/smp46/smp46.github.io/nextjs/assets/smartgarage/software.png?q=85&f=webp)\n\n##### The Components\n\n###### [**Rust HTTP API Server**](https://github.com/smp46/SmartGarage/tree/main/garage_door_api)\n\nInitially this was just another Python FastAPI, but I switched to Rust, using\nAxum Server, because it needs to be running 24/7 and I don't want my poor little\nPi Zero W running too hard. The server listens on port `3000` for a POST request\nto the `/toggle` endpoint with the correct authorisation token, when received it triggers the\nbutton on the fob and the door opens or closes.\n\n###### [**Fetch Video Snapshot Bash Script**](https://github.com/smp46/SmartGarage/blob/main/garage-img.sh)\n\nEvery second a script retrieves a snapshot of the garage security camera feed\nand saves this to a RAM-disk. A RAM-disk is used to prevent excessive wear and\ntear from constant writes to the system drive. A custom systemd service is used\nto trigger this every second, as crontab is limited to once per minute.\n\n###### [**Image Recognition Script**](https://github.com/smp46/SmartGarage/blob/main/image_recognition/garage_monitor.py)\n\nThis is a variant of `justPredict.py` script mentioned before, except it reads a\nfile from a specified path and sends its results to the Garage Door Status API.\nAgain, I use a custom systemd service to keep this script running and restart it\non boot.\n\n###### [**Garage Door Status API**](https://github.com/smp46/SmartGarage/blob/main/status_api/app/main.py)\n\nSuper simple Python HTTP API server, using FastAPI, that receives and stores the garage\ndoor status from the Image Recognition Script and updates its internal last_opened\nstate if the status changes from closed to open. And then responds with this\ndata in a JSON response when a POST request is sent to\n`http://garage-api:5000/status`.\n\n###### [**Homepage Custom API Widget**](https://gist.github.com/smp46/37efd7d30b2980b4553c148d08c0b969)\n\nThis widget lives on my homepage and provides the snapshot from the camera, the\nstatus of the door as reported by the Garage Door Status API and the time it was\nlast opened. The preview is using an iframe that just displays the snapshot\nimage, where the iframe html is mounted to the homepage docker container.\n\n![widget_preview](https://cdn.statically.io/gh/smp46/smp46.github.io/nextjs/assets/smartgarage/homepage_widget.png?q=85&f=webp)\n\n###### [**Email Notification Service**](https://github.com/smp46/SmartGarage/blob/main/garage_notifs.sh)\n\nThis is a bash script that is run every minute with crontab. It checks the\nStatus API for the current status and the last opened status, if it is currently\nopen and the last opened was more than 10 minutes ago it sends a friendly email\nwith a link to the website to close it.\n\n###### [**SmartGarage Control Website**](https://github.com/smp46/SmartGarage/tree/main/website)\n\nThis website provides the snapshot of the security camera and has a button that\nsends a POST request through an nginx proxy to the Rust HTTP API Server on the\nPi. The website is hosted via nginx through a Cloudflare Tunnel, using Google\nSSO it is protected against unwanted visitors.\n\n![website](https://cdn.statically.io/gh/smp46/smp46.github.io/nextjs/assets/smartgarage/website.png?q=85&f=webp)\n\n## The Result\n\n###### But at What Cost?\n\nNot too much actually, if we ignore how many hours I put into this, and there's\na few things leftover / will be used when I do something similar again. \n\n| Component | Cost (AUD) |\n| :--- | ---: |\n| Raspberry Pi Zero W | $25.00 |\n| Pi GPIO Pins and Case | $8.00 |\n| Generic Garage Door Fob | $8.00 |\n| 5V Relay | $8.00 |\n| 220 Ohm 0.5 Watt Resistors | $0.85 |\n| Soldering Iron kit | $45.00 |\n| **Total** | **$94.85** |\n\n\n###### To Conclude\n\nAfter several months of development, testing, and refinement, I'm happy to\nreport that my SmartGarage system has been running reliably for over a month\nnow. The system successfully:\n\n- Allows me to remotely open and close my garage door from anywhere with\n  internet access\n- Detects the door's open/closed state with reasonable accuracy\n- Sends me notifications if I've left the door open for more than 10 minutes\n- Provides a remotely accessible, nearly real-time view of my garage through via the camera\n\nHere's a demo of it in action:\n![demo](https://cdn.statically.io/gh/smp46/smp46.github.io/nextjs/assets/smartgarage/demo.webp)\n",
            "url": "https://smp46.me/projects/SmartGarage",
            "title": "SmartGarage",
            "summary": "SmartGarage is a custom-built IoT solution that enables remote garage door control without modifying the original opener. Using a Raspberry Pi, relay circuit, and machine learning image recognition, it provides door status monitoring, remote operation, and automated notifications—all built with off-the-shelf components.",
            "date_modified": "2025-05-14T00:00:00.000Z",
            "date_published": "2025-05-11T00:00:00.000Z"
        },
        {
            "id": "https://smp46.me/projects/MazeGame",
            "content_html": "\n# MazeGame: A JavaFX Puzzle Game with Dynamic Mazes and BFS Solver\n\nThis is a game I completed in my Intro to Java class. I went far beyond what\nthey asked of us, so here it is.\n\nA goose named Sir Wobbleton is stuck in a dynamically loaded maze (of your\nchoosing), you must get him out (or simply press 'Q' and allow the maze solver\nto solve the maze). Mazes can be loaded from any file that matches the given\nformat (Theoretically can be infinitely big). The game also can be loaded in\nthree different ways: CLI mode, GUI no-asset mode, and GUI asset mode. Due to\nlicensing, I cannot include the asset folder in the source code, however do not\nworry I implemented an MD5 checksum check to verify all assets before\ndisplaying. If the assets don't match the checksum, the game will work just\nfine. Checkout below.\n\n![Demo](https://cdn.statically.io/gh/smp46/smp46.github.io/nextjs/assets/mazegame/GUI_Assets.gif)\n\n### Notable Features:\n\n- Breadth First Solver, because any maze (matching the spec) can be loaded, BFS\n  is utilised to autosolve any possible maze.\n- Dynamic texture loading, using MD5 hashing the game can identify if assets are\n  missing and/or incorrect and switch to an asset-free mode.\n- Dynamic texture picking, I pain stakingly matched every possible maze wall\n  position to the right texture so Sir Wobbleton and his maze will always look\n  good.\n- Object Oriented design, both the GUI and CLI utilise the very same game\n  framework for modularity and ease of use.\n- Multithreaded optimisation, the BFS maze solver runs on a dedicated thread to\n  prevent slowdowns when launching the game.\n\n### Game Controls:\n\n- _WASD_ for movement.\n- _Q_ to autosolve maze.\n- _H_ to enable path highlighting.\n\n## Three Exciting Game Modes:\n\n### CLI Mode\n\n![cli medium maze](https://cdn.statically.io/gh/smp46/smp46.github.io/nextjs/assets/mazegame/CLI.png?q=85&f=webp)\n\n### GUI No-Assets Mode\n\n![gui medium maze no-asset](https://cdn.statically.io/gh/smp46/smp46.github.io/nextjs/assets/mazegame/GUI_No_Assets.png?q=85&f=webp)\n\n### GUI Assets Mode\n\n![gui medium maze](https://cdn.statically.io/gh/smp46/smp46.github.io/nextjs/assets/mazegame/GUI_Assets.png?q=85&f=webp)\n\n## Launching the Game\n\n- JavaFX library is required.\n- Developed and tested with JDK 17.\n\nCommand line arguments should be passed to the Launcher.class file in this\nformat:\n\n`java Launcher [CLI or GUI] [relative dir of maze file]`\n\nSo for example to load the GUI with the medium maze:\n\n`java Launcher GUI src/maps/maze002.txt`\n\n## Creating Your Own Mazes\n\nIf you want to make your own mazes, here is the specification the maze files\nmust match:\n\n- The maze's dimensions must be in the file's first line in the form of two\n  integers, both must be odd numbers to ensure the maze has an external wall and\n  internal paths.\n- The remaining maze attributes have to be provided in the following char\n  configurations:\n  - Walls - `#`\n  - Traversable Paths - `' '` or `.`\n  - Start Point - `S`\n  - End Point - `E`\n\nSo the text file of the small maze shown above looks like this:\n\n```\n7 7\n#######\n#S#   #\n# ### #\n# #   #\n# # # #\n#   #E#\n#######\n```\n\nFeel free to contribute, suggest improvements, or report bugs!\n\nIf anyone is interested, I'd be happy figure out how to release a compiled jar\nincluding the assets.\n",
            "url": "https://smp46.me/projects/MazeGame",
            "title": "MazeGame",
            "summary": "MazeGame is a Java-based puzzle game featuring a goose navigating dynamic mazes with autosolve functionality using BFS. Includes CLI and GUI modes with asset integrity checks.",
            "date_modified": "2025-05-13T00:00:00.000Z",
            "date_published": "2024-11-22T00:00:00.000Z"
        },
        {
            "id": "https://smp46.me/projects/PortfolioWebsite",
            "content_html": "\n# Building My Developer Portfolio with Next.js, MDX, and GitHub Actions\n\nThis is the website you're on right now! It covers an intro to my projects (like\nthis one) and a little about who I am.\n\n## Features\n\n- Written in Typescript with NextJS/React.\n- Fully dynamic will scale (well) to most devices.\n- Website is entirely statically generated.\n- Articles (projects) are written in MDX format and get compiled automatically\n  as a Github workflow.\n\n## How the Markdown stuff works\n\nPainfully! It was a lot of banging my head against the wall using various guides\nand resources to reach my goal of _easier_ article creation / updating. What\nended up being the most helpful article was\n[this one by Colby Fayock](https://spacejelly.dev/posts/how-to-source-mdx-content-in-next-js-to-dynamically-create-pages-for-a-blog).\n\nThe end result is a relatively easy way to maintain and add articles/project\nwrite-ups. The process is as simple as:\n\n1. Write the article in Markdown(X) and copy it to the src/projects directory.\n2. Add the required fields to the top of the page, to extract a title and allow\n   for categorising, meta tags etc. For example:\n\n```\n---\ntitle: \"Portfolio Website\"\nsubtitle: \"Building My Developer Portfolio with Next.js, MDX, and GitHub Actions\"\ntype: \"personal\"\ndescription: \"A fully statically-generated personal portfolio built with Next.js, React, and TypeScript. It showcases projects, articles written in MDX, and a bit about me.\"\nkeywords: \"personal website, portfolio, Next.js, React, TypeScript, static site generation, MDX, GitHub Actions, web development, developer portfolio\"\ngithub: \"https://github.com/smp46/smp46.github.io\"\n---\n```\n\n3. `git add . && git commit` And ta-dah, the Github workflow handles the\n   compiling and then it goes live at\n   [smp46.me/projects](https://smp46.me/projects).\n\n### Testing/Building\n\nRequirements: `npm 10.9.2` - ymmv with other versions\n\nFor developing `npm run dev`, this even works for adding MDX files. Navigating\naway then back to /projects, will refresh and get new files.\n\nFor building/generating a static site `npm run build`, find the website files in\n/out.\n",
            "url": "https://smp46.me/projects/PortfolioWebsite",
            "title": "Portfolio Website",
            "summary": "A fully statically-generated personal portfolio built with Next.js, React, and TypeScript. It showcases projects, articles written in MDX, and a bit about me.",
            "date_modified": "2025-05-13T00:00:00.000Z",
            "date_published": "2025-04-08T00:00:00.000Z"
        },
        {
            "id": "https://smp46.me/projects/RightClickVirusTotal",
            "content_html": "\n# RightClickVirusTotal: Cross-Platform File Scanning with VirusTotal API\n\nRightClickVirusTotal is a Python program that provides a simple local interface\nfor the VirusTotal API, via the vt-py library.\n\nDesigned to be add to the Windows context menu, it allows you to easily check\nany files for viruses before running them.\n\nNow cross-platform! Checkout the latest releases for Windows and Linux specific\nbuilds.\n\n_Demo of Windows GUI_\n\n![Windows_GUI_demo](https://cdn.statically.io/gh/smp46/smp46.github.io/nextjs/assets/rcvt/Windows_GUI.gif)\n\n_Demo of Universal GUI_\n\n![universal_gui_demo](https://cdn.statically.io/gh/smp46/smp46.github.io/nextjs/assets/rcvt/Universal_GUI.gif)\n\n_Screenshot of Universal CLI_\n\nThere is also now a CLI version, with builds for both Windows and Linux:\n![universal_cli_demo](https://cdn.statically.io/gh/smp46/smp46.github.io/nextjs/assets/rcvt/Universal_CLI.png?q=85&f=webp)\n\n## Key Features\n\n- Utilizes the VirusTotal API to upload files and retrieve analysis results.\n- Displays comprehensive statistics on the file's detection status, including\n  harmless, malicious, suspicious, and undetected classifications.\n- Built with a user-friendly graphical interface using the Tkinter library.\n\n**Note:** Before using the program, make sure to obtain a valid VirusTotal API\nkey (these are free for basic personal use).\n\n### Pick the Right Version\n\nThere are three versions of RightClickVirusTotal, these are:\n\n- Universal_CLI - A Command Line Interface version to be used in the terminal.\n  Use this if most of your work is does in a terminal.\n- Universal*GUI - A Graphical User Interface version that can be used anyway a\n  TKinter GUI can be launched, Windows, Linux or OSX. Use this if you want a GUI\n  and you're \\_not* using Windows.\n- Windows*GUI - A Graphical User Inferface version with specific features and\n  optimisations for Windows 10/11. Use this if you want a good GUI and \\_Right\n  Click* functionality on Windows.\n\n## Basic Usage Instructions for Windows GUI\n\nUnlike the Universal Versions, Windows GUI can be run with no arguments. Opening\nit without arguments and admin permissions will open the program, which will\nthen relaunch and request admin permissions. Then you are presented with two\nwindows that look like this:\n![image](https://cdn.statically.io/gh/smp46/smp46.github.io/nextjs/assets/rcvt/Windows_Instructions.png?q=85&f=webp)\n\nHere you can input your VirusTotal API key, and the program will add a shortcut\n**to the programs current location**, meaning if you move the .exe the shortcut\nwill no longer work, so only do this once you have placed it where you want to\nkeep it, to the Windows Right Click Context Menu like shown in the demo at the\ntop of the page. Then you can launch the program from any folder in file\nexplorer by simply right clicking and selecting `Upload to VirusTotal`.\n\nThe usage instructions for the Universal Versions below are also valid for the\nWindows GUI.\n\n## Basic Usage Instructions for Universal Versions\n\nArguments must be provided _to get the program to do anything_, otherwise a\nusage error will be printed (for the CLI) and program will exit.\n\nThe below example is for the Linux executable, but arguments are provided the\nsame regardless of the platform.\n\n`./RightClickVirusTotal_CLI_Universal \"VirusTotalAPIKey\" \"FilePath\"`\n\nEnsure you replace the first argument, VirusTotalAPIKey, with your own API key\nand keep the quotation marks to ensure it is passed as a string. Then the second\nargument, FilePath, should be the whole path to the file, again also in quotes.\n\nFor example on Linux:\n\n`./RightClickVirusTotal_CLI_Universal \"0010101010101abcdefq\" \"/home/smp/Documents/RightClickVirusTotal/realvirus.txt\"`\n\n## Current Issues\n\n- None known.\n\n## FAQ\n\n**Where can I get a VirusTotal API Key?**\n\nCreate a free account over at [VirusTotal](https://www.virustotal.com), then\nclick on your profile icon in the top right corner of the homepage, and select\n\"API Key\".\n\n**Why is \\<insert RightClickVirusTotal build name\\> being detected as a virus by\nmy anti-virus and VirusTotal?**\n\nRightClickVirusTotal is both unsigned and compiled with PyInstaller, so it can\nmatch anti-virus patterns used to detect malware. Unfortunately if it's easy to\nuse for solo-devs it also can be used to make malware. These _are false\npositives_. If you are concerned at all, please review the source code and build\nit yourself using the instructions below!\n\n**Why do some files take so long to analyse?**\n\nIf a file doesn't already exist in the VirusTotal database, it needs to be\nscanned and analysed this can, at times, take up to two minutes or more\ndepending on the file size. It is also a limitation of the free API access, when\na file is being analysed I can only check in with VirusTotal API every 15\nseconds (4 lookups/min).\n\n## Build Instructions using PyInstaller\n\n**Made and built using Python 3.11.2**\n\n### Windows GUI\n\n1. Open powershell and run `pip install pyinstaller tk vt-py asyncio pillow`\n\n2. Navigate to a directory to store the project in and run\n   `git clone https://github.com/smp46/RightClickVirusTotal.git ; cd RightClickVirusTotal`\n\n3. Run the following command to build the executable:\n   `pyinstaller --onefile --noconsole --icon=imgs/rcvt.ico --add-data=\"imgs/;imgs\" .\\RightClickVirusTotal_GUI_Windows.py`\n\n   This command instructs PyInstaller to create a single executable file\n   (`RightClickVirusTotal_GUI_Windows.exe`) that contains your program, its\n   dependencies and resources.\n\n4. Inside the `dist` directory, you will find the executable file\n   (`RightClickVirusTotal_GUI_Windows.exe`).\n\n5. Move this file to anywhere you want to 'install' it.\n\n### Universal GUI\n\n1. nstall required dependencies with pip\n   `pip install pyinstaller tk vt-py asyncio ttkthemes`\n\n2. Navigate to a directory to store the project in and run\n   `git clone https://github.com/smp46/RightClickVirusTotal.git ; cd RightClickVirusTotal`\n\n3. Run the following command to build the executable:\n   `pyinstaller --onefile --noconsole --icon=imgs/rcvt.ico .\\RightClickVirusTotal_GUI_Universal.py`\n\n   This command instructs PyInstaller to create a single executable file\n   (`RightClickVirusTotal_GUI_Universal.`) that contains your program, its\n   dependencies and resources.\n\n4. Inside the `dist` directory, you will find the executable file\n   (`RightClickVirusTotal_GUI_Universal`).\n\n### Universal CLI\n\n1. Install required dependencies with pip\n   `pip install pyinstaller vt-py colorama`\n\n2. Navigate to a directory to store the project in and run\n   `git clone https://github.com/smp46/RightClickVirusTotal.git ; cd RightClickVirusTotal`\n\n3. Run the following command to build the executable:\n   `pyinstaller --onefile RightClickVirusTotal_CLI_Universal.py`\n\n   This command instructs PyInstaller to create a single executable file\n   (`RightClickVirusTotal_CLI_Universal`) that contains your program and its\n   dependencies.\n",
            "url": "https://smp46.me/projects/RightClickVirusTotal",
            "title": "RightClickVirusTotal",
            "summary": "RightClickVirusTotal is a Python-based tool that adds file virus scanning directly to your context menu via the VirusTotal API. Now available with CLI and GUI for Windows, Linux, and macOS.",
            "date_modified": "2025-05-13T00:00:00.000Z",
            "date_published": "2024-11-22T00:00:00.000Z"
        },
        {
            "id": "https://smp46.me/projects/StoryPath",
            "content_html": "\n# StoryPath: A Location-Based Platform for Interactive Tours & Treasure Hunts\n\nStoryPath is a location-based experience platform built for virtual museum\nexhibits, interactive tours, and clue-driven treasure hunts. It includes both a\nReact Web App for creating experiences and a React Native App for exploring them\nin the real world.\n\n### Tech Stack\n\nFrontend Web: React, TypeScript, Vite, Tailwind CSS, Axios\n\nMobile App: React Native, TypeScript, Tailwind CSS, Axios, Expo\n\nBackend: Provided REST API or local JSON Server, ChatGPT API\n\n## Website\n\nThe StoryPath web app provides a project creation interface with a REST API\nbackend that gets shared with the app.\n\n### Features\n\n- Create and manage location-based projects\n\n- Add Locations to each project, with support for custom content including\n  images for each location.\n\n- Print unique QR codes for each location for discovery via the mobile app\n\n- Use a basic Preview Mode to simulate the app experience\n\n- ChatGPT integration to enhance or get feedback on project content\n\n### Demo\n\n![StoryPathWebDemo](https://cdn.statically.io/gh/smp46/smp46.github.io/nextjs/assets/storypath/web_demo.gif)\n\n## Companion App\n\nThe StoryPath mobile app (React Native) enables users to play experiences\ncreated on the web platform. Once a user creates a profile (locally stored),\nthey can browse available projects and start exploring. Locations are unlocked\nby physically visiting them or scanning the associated QR code. Each discovery\nupdates the user’s score and reveals the next clue.\n\n### Features\n\n- Create a player profile with name and photo\n\n- Browse and select from a list of published projects\n\n- Follow clues to find locations\n\n- Unlock locations by entering a geofenced area or scanning a QR code\n\n- View your current location and unlocked spots on a map\n\n- Track your score and progress through the experience\n\n- See participant stats for each project/location\n\n### Demo\n\n![StoryPathAppDemo](https://cdn.statically.io/gh/smp46/smp46.github.io/nextjs/assets/storypath/app_demo.gif)\n\n## Setup Instructions\n\nThe app and website _can_ be run locally with the caveat that the API has just\nbeen reimplemented with json-server. And the ChatGPT functionaility won't work\nwithout providing API keys in the .env file.\n\n### Prerequisites\n\n- Node.js (>= 18.x recommended)\n\n- Yarn or npm\n\n- Android Developer Studio (for emulation) or a mobile device with the Expo App\n  installed.\n\n#### Website Setup\n\n```\n# Clone the repo\ngit clone https://github.com/smp46/StoryPath.git\ncd React\\ Website/\n\n# Install dependencies\nnpm install\n\n# Start development server\nnpm run dev\n```\n\nThis starts the web app at http://localhost:5173.\n\n##### Mobile App Setup\n\n```\n# Clone the repo\ngit clone https://github.com/smp46/StoryPath.git\ncd React\\ Native/\n\n# Install dependencies\nnpm install\n\n# Start the Expo development server\nnpx expo start\n```\n\nYou can scan the QR code from your terminal or browser to open the app on your\nphone using the Expo Go app.\n",
            "url": "https://smp46.me/projects/StoryPath",
            "title": "StoryPath",
            "summary": "StoryPath is a cross-platform experience builder for creating location-based virtual museum exhibits, clue-driven treasure hunts, and interactive tours. Built with React, React Native, and Expo.",
            "date_modified": "2025-05-13T00:00:00.000Z",
            "date_published": "2025-04-15T00:00:00.000Z"
        },
        {
            "id": "https://smp46.me/projects/UQInc",
            "content_html": "\n# UQInc: A Rust-Powered UQ Campus Clicker Game\n\n[![Github All Releases](https://img.shields.io/github/downloads/UQInc/UQInc/total.svg)]()\n\nAn idle clicker game where you can live your dream of building the University of\nQueensland. Brought to you in Rust.\n\nWritten in 48 Hours for the UQCS 2024 Hackathon, by a team who had never\ndeveloped collaboratively or writtten in Rust.\n\n![Screenshot](https://cdn.statically.io/gh/smp46/smp46.github.io/nextjs/assets/uqinc/uqinc.png?q=85&f=webp)\n\n# How to Run\n\n### From Source\n\nUQInc requires rust and cargo in order to run. To start, in the terminal run:\n\n```\ngit clone https://github.com/UQInc/UQInc.git\ncd UQInc\ncargo run\n```\n\n### From Pre-Built Executables\n\nPick the executable for your platform\n[here](https://github.com/UQInc/UQInc/releases/)!\n\nFrom there the game will open and you can begin clicking and buying upgrades to\nplay. Upon completion the buildings menu on the right hand side will be empty\nand the map will be complete. Each building purchase will award 1 perk point\nwhich can be spent in the perks menu to increase the number of students per\nclick and the amount of money you get per student.\n\n# GUI\n\nMade using the macroquad library.\n",
            "url": "https://smp46.me/projects/UQInc",
            "title": "UQInc",
            "summary": "UQInc is a fast-paced idle clicker game built in Rust during the UQCS 2024 Hackathon. Construct your dream University of Queensland campus, upgrade buildings, and earn perks—all within a retro-style GUI built with macroquad.",
            "date_modified": "2025-05-13T00:00:00.000Z",
            "date_published": "2024-11-22T00:00:00.000Z"
        },
        {
            "id": "https://smp46.me/projects/dockerImageServer",
            "content_html": "\n# dockerImageServer: Docker Image Server for Periodic Image Fetching with Nginx\n\nThis Docker container downloads an image from a specified URL at regular\nintervals and serves it via an Nginx web server. I'm publishing it here in hope\nthat someone else might have a use for it. My use case is fetching a snapshot\nimage from a security camera on my local network and exposing it safely behind a\nnginx web server that can then be put behind a reverse-proxy.\n\n## Prerequisites\n\n- Docker installed on your machine.\n- Basic knowledge of Docker command-line usage.\n\n## Configuration\n\nConfiguration is handled through environment variables. The following variables\ncan be set:\n\n- `IMAGE_URL`: The URL of the image to be downloaded and served. (Required)\n- `SLEEP_INTERVAL`: The interval, in seconds, between each image fetch. Defaults\n  to `5` seconds.\n\n## Quick Start\n\n**Docker Run**\n\n```bash\n  docker run -d -p 8080:80 \\\n  -e IMAGE_URL=your_image_url_here \\\n  -e SLEEP_INTERVAL=10 \\\n  ghcr.io/smp46/dockerimageserver\n```\n\n**Docker Compose**\n\n```yaml\ndockerImageServer:\n  container_name: dockerImageServer\n  ports:\n    - 8080:80\n  image: ghcr.io/smp46/dockerimageserver\n  environment:\n    - IMAGE_URL=your_image_url_here\n    - SLEEP_INTERVAL=10\n  restart: unless-stopped\n```\n\nThis will start the container and begin serving the image at\nhttp://localhost:8080.\n\n## Build from Source\n\n1. **Clone the Repository**\n\n   ```bash\n   git clone https://github.com/smp46/dockerImageServer\n   cd dockerImageServer\n\n   ```\n\n2. Build the Docker Image\n\n   ```bash\n   docker build -t dockerimageserver .\n\n   ```\n\n3. Run the Docker Container.\n\n   Replace your_image_url_here with the actual URL of the image you want to\n   serve and optionally adjust the SLEEP_INTERVAL.\n\n   ```bash\n   docker run -d -p 8080:80 \\\n     -e IMAGE_URL=your_image_url_here \\\n     -e SLEEP_INTERVAL=10 \\\n     dockerimageserver\n   ```\n\nThis will start the container and begin serving the image at\nhttp://localhost:8080.\n",
            "url": "https://smp46.me/projects/dockerImageServer",
            "title": "dockerImageServer",
            "summary": "dockerImageServer is a lightweight Docker container that periodically downloads an image from a URL and serves it via Nginx. Ideal for use cases like exposing security camera snapshots through a reverse proxy.",
            "date_modified": "2025-05-13T00:00:00.000Z",
            "date_published": "2024-11-22T00:00:00.000Z"
        }
    ]
}